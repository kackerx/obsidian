#ç®—æ³•-å›æº¯ 

## ç»„åˆ
--- start-multi-column: ID_2cos
```column-settings
Number of Columns: 2
Largest Column: standard
Border: off
Shadow: off
```

### 216 - ç»„åˆæ€»å’Œ3
![[Pasted image 20240919112456.png|577]]
?
```go
func combinationSum3(k int, n int) [][]int {
	res := make([][]int, 0)
	back3(n, k, 1, 0, []int{}, &res)
	return res
}

func back3(n, k, idx, sum int, track []int, res *[][]int) {
	if len(track) == k && sum == n {
		*res = append(*res, slices.Clone(track))
		return
	}

	for i := idx; i <= 9; i++ {
		track = append(track, i)
		sum += i
		back3(n, k, i+1, sum, track, res)
		sum -= i
		track = track[:len(track)-1]
	}
}
```

--- column-break ---

### 40 - ç»„åˆæ€»å’Œ2/M
![[Pasted image 20240919112542.png|577]]
?
```go
func combinationSum2(candidates []int, target int) [][]int {
	var (
		res   [][]int
		track []int
	)
	slices.Sort(candidates)
	backk(candidates, 0, track, &res, target, 0)
	return res
}

func backk(candidates []int, index int, track []int, res *[][]int, target, sum int) {
	if sum == target {
		*res = append(*res, slices.Clone(track))
		return
	}

	if sum > target { // å·²ç»å¤§äºç›®æ ‡å€¼ç›´æ¥return
		return
	}

	for i := index; i < len(candidates); i++ {
		// å¯é‡å¤è¦å‰ªæ, i>idx, æ’åº, continue
		if i > index && candidates[i] == candidates[i-1] {
			continue
		}

		track = append(track, candidates[i])
		sum += candidates[i]
		backk(candidates, i+1, track, res, target, sum)
		track = track[:len(track)-1]
		sum -= candidates[i]
	}
}
```

--- end-multi-column

---
--- start-multi-column: ID_2cos
```column-settings
Number of Columns: 2
Largest Column: standard
Border: off
Shadow: off
```

### 39 - ç»„åˆæ€»å’Œ/M
![[Pasted image 20240919112439.png|577]]
?
```go
// æ— é‡å¤å¯å¤é€‰
func combinationSum(candidates []int, target int) [][]int {
	var (
		res   [][]int
		track []int
		sum   int
	)

	backkkk(candidates, track, &res, 0, target, sum)
	return res
}

func backkkk(candidates []int, track []int, res *[][]int, index int, target int, sum int) {
	if sum == target {
		*res = append(*res, slices.Clone(track))
		return
	}

	if sum > target {
		return
	}

	for i := index; i < len(candidates); i++ {
		track = append(track, candidates[i])
		sum += candidates[i]
		backkkk(candidates, track, res, i, target, sum)
		sum -= candidates[i]
		track = track[:len(track)-1]
	}
}
```

--- column-break ---



--- end-multi-column

## å­é›†

--- start-multi-column: ID_2cos
```column-settings
Number of Columns: 2
Largest Column: standard
Border: off
Shadow: off
```

### 78-å­é›†/M
![[Pasted image 20240919113218.png|577]]
?
```go
func subsets(nums []int) [][]int {
	var res [][]int
	slices.Sort(nums)
	backtrackk(nums, 0, []int{}, &res)

	return res
}

func backtrackk(nums []int, index int, track []int, res *[][]int) {
	*res = append(*res, slices.Clone(track))

	for i := index; i < len(nums); i++ {
		track = append(track, nums[i])
		backtrackk(nums, i+1, track, res)
		track = track[:len(track)-1]
	}
}
```

--- column-break ---

### 90-å­é›†2/M
	![[Pasted image 20240919113707.png|577]]
?
```go
func subsetsWithDup(nums []int) [][]int {
	res := [][]int{}
	track := []int{}
	slices.Sort(nums)
	backtr(nums, track, 0, &res)
	return res
}

func backtr(nums []int, track []int, index int, res *[][]int) {
	*res = append(*res, slices.Clone(track))

	for i := index; i < len(nums); i++ {
		// å‰ªææ“ä½œ, å€¼ç›¸åŒçš„ç›¸é‚»æ ‘æ, éå†ç¬¬ä¸€æ¡, æŸ¥çœ‹é€’å½’ğŸŒ², æ¯ä¸ªææ˜¯ä¸€ä¸ªå¾ªç¯è®°ä¸‹indexæ¨¡æ‹Ÿ
		if i > index && nums[i] == nums[i-1] {
			continue
		}

		track = append(track, nums[i])
		backtr(nums, track, i+1, res)
		track = track[:len(track)-1]
	}
}
```

--- end-multi-column

## å…¨æ’åˆ—

--- start-multi-column: ID_2cos
```column-settings
Number of Columns: 2
Largest Column: standard
Border: off
Shadow: off
```

### 46-å…¨æ’åˆ—/M
![[Pasted image 20240919115238.png|577]]
?
```go

func permute1(nums []int) [][]int {
	res := make([][]int, 0)
	used := map[int]bool{}
	back2(nums, []int{}, &res, used)
	return res
}

func back2(nums []int, track []int, res *[][]int, used map[int]bool) {
	if len(track) == len(nums) {
		*res = append(*res, slices.Clone(track))
		return
	}

	for i := 0; i < len(nums); i++ {
		if used[i] {
			continue
		}
		used[i] = true
		track = append(track, nums[i])
		back2(nums, track, res, used)
		used[i] = false
		track = track[:len(track)-1]
	}
}
```

--- column-break ---

### 47-å…¨æ’åˆ—2/M
![[Pasted image 20240919115900.png|577]]
?
```go
func permuteUnique(nums []int) [][]int {
	var (
		res   [][]int
		track []int
		used  = make([]bool, len(nums))
	)
	slices.Sort(nums)
	backkk(nums, track, used, &res)
	return res
}

func backkk(nums []int, track []int, used []bool, res *[][]int) {
	if len(track) == len(nums) {
		*res = append(*res, slices.Clone(track))
		return
	}

	for i := 0; i < len(nums); i++ {
		if used[i] {
			continue
		}

		if i > 0 && nums[i] == nums[i-1] && !used[i-1] { // æœ€åä¸€ä¸ªæ¡ä»¶æ˜¯é¿å…å½“å‰åˆ°å¶å­çš„æä¸è¢«å‰ªæ‰, åªå‰ªæ°´å¹³çš„å¾ªç¯é€‰æ‹©
			continue
		}

		track = append(track, nums[i])
		used[i] = true
		backkk(nums, track, used, res)
		used[i] = false
		track = track[:len(track)-1]
	}
}
```

--- end-multi-column