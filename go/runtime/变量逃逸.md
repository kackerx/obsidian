# 变量逃逸

&  变量携带一组检验数据, 证明它整个生命周期是否在运行时完全可知, 如果变量通过检验, 可以在栈上分配, 否则逃逸到堆上


- 悬垂指针
- 发送指针或带有指针的值到chan中, 编译期没法知道是哪个goro会来该chan接收, 所以编译器不知道什么时候会释放
- 指针或带有指针的值的切片, 如[]\*string, 切片的内容逃逸, 尽管底层数组可能是栈上分配, 引用的值一定在堆上
- slice背后的数组重新分配, 切片背后的存储, 基于运行时扩容, 就会在堆上分配
- interface类型调用方法, interface类型都是动态调度, 只有运行时才知道, 在堆上分配