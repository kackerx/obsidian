# Mutex

## 结构

```go
type Mutex struct {
	state int32   // 状态
	seam  uint32  // 信号量
}
```

![[Pasted image 20221109102628.png|700]]
> 允许自旋的条件: 锁被占用, 且正常模式下, 积累的自旋次数 < 最大自旋次数(active_spin=4), cpu核心 > 1, 有空闲的P, 当前goro的P本地队列为空

- Mutex的状态是上锁和解锁函数中使用atomic包原子操作该值
- 新来goro会自旋, 然后尝试获取锁, 获取不到加入等待队列先入先出
- 当锁被释放, 第一个等待者被唤醒要和新来的多个运行中的goro竞争, 大概率失败
- 等待goro抢锁失败会重新插入队列头部, 当一个goro本次加锁等待时间超过1ms, 切换饥饿模式
    - 饥饿模式下, 执行所有权从解锁的goro直接传递给等待队列头部的goro
    - 新来的goro不会尝试抢占, 而是直接插入队列尾部
    - 排队的goro等待时间小于1ms ==or== 排队goro是最后一个等待者, 等待队列空了, 切换回正常模式

---


![[Pasted image 20221109103433.png|700]]
- 正常模式下, 抢占式吞吐高, 尾端可能抢不到
- 饥饿模式下, 严格按照先入先出顺序

## state

![[Pasted image 20221109103952.png|700]]
- 第一位: 是否上锁, 第二位: 是否已经goro唤醒, 第三位: 1饥饿模式, 其他位记录多少个等待者在排队
- 新来自旋的goro会争抢mutex的唤醒标识位Woken, 为了正常模式下告诉持有锁的goro不用唤醒其他goro了, 已经有新来的在等待释放了

## sema

> 处理沉睡和唤醒的信号量, 依赖两个runtime调用

- semacquireMutex: sema + 1, 挂起一个goro
- semrelease: sema - 1, 唤醒一个goro

## QA

- 关于单核
    - 单核场景下, 当前锁被占用, 新来的goro如果自旋去等待锁释放, 持有锁的goro等待自旋的goro让出cpu, 没有意义, 如果核心大于1, 有空闲的p, p的本地队列不为空, 也不会自旋