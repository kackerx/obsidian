# RWMutex

> 只有写锁, 没有读锁, 会读到变量的中间状态, 保证读的原子性也要加读锁

## 结构

```go
type RWMutex struct {  
   w           Mutex  //用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此  
   writerSem   uint32 //写阻塞等待的信号量，最后一个读者释放锁时会释放信号量  
   readerSem   uint32 //读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量  
   readerCount int32  //记录读者个数  
   readerWait  int32  //记录写阻塞时读者个数  
}
```

## 接口

- ==Lock==
    - 获取写锁多个写锁在Lock处排队, 其中一个获取互斥锁
    - 如果当前readerCount > 0, 会阻塞并等待读结束, 相反则直接结束, 上写锁成功
- ==Unlock==
    - 如果readerCount > 0, 该函数先唤醒阻塞的读锁goro, 然后如果有阻塞的写锁goro也会唤醒
    - 解锁写锁
- ==RLock==
    - 增加readerCount++
    - 如果有写锁, 阻塞等待写锁结束, 没有写锁直接获取读锁
- ==RULock==
    - 减少readerCount--
    - 有写锁, 并且当前是最后一个读锁的话会唤醒阻塞等待写锁的goro
    - 解锁

## 写锁的插队策略

> 防止一直有读锁进来导致的写锁饥饿, 所以写锁需要插队

![[Pasted image 20221124172721.png|700]]
![[Pasted image 20221124172857.png|700]]

## QA

- 写操作如何阻止写操作
    - 通过自带的互斥锁

- 写操作如何阻止读操作
    - 不考虑写操作的话, 每次加读锁readerCount++, 解锁--, 最大支持2^30
    - 写锁进行时会把count - 2^30, 负值读阻塞, 写锁解锁count + 2^30, 不会丢失读者数量

- 写操作为什么不会被饿死
    - 写操作到来会把readerCount拷贝到readerWait, 读操作结束递减Count和Wait, Wait=0唤醒写操作


