# 事务 #index 

:::::::::::::::::::::::::::::::::::::::: {.columns border=off col-count=2 largest-column=firs}

~~~ad-tips
title: ACID

- C: 一致性由AID三个结合来保证, 一般还由应用层来保证, 虽然基于<mark class="hltr-pink">外键约束</mark>也是一致性的保证
- A: 原子性(undo日志回滚)undo日志来保证
- I: 隔离性(MVCC读视图)由MVCC, 意味着可以假装本事务是唯一在执行的事务, 保证多事务提交时, 结果与串行提交一致
- D: 持久性由redo日志, redo buffer, 事务提交日志肯定存在防止宕机未刷盘

~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20230713113146.png|555]]

- 隔离级别分别解决的并发事务问题
- 所谓脏写和脏读, 都是一个事务A更<mark class="hltr-pink">新或者查询</mark>了另一个事务B还未提交的数据

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
:::::::::::::::::::::::::::::::::::::::: {.columns border=off col-count=2 largest-column=firs}

```ad-bug
title: 幻读问题解决

- 幻读特指: 读到了之前不存在的新数据

---

- 对于快照读(select): MVCC解决, 插入的新数据是看不到的
- 对于当前读(select for update): 通过`next-key lock`(记录锁+间隙锁), 其他事物的插入会阻塞
```

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-ex
title: 快照读 & 当前读

- 快照读: 事务开启时的read-view, 读已提交的话是每次读生成read-view
--- 

- 写操作还是要在最新值上去做的
- 更新数据都是先读, 后写, 这个读只能读当前值(current read)
- <mark class="hltr-pink">update语句</mark>和<mark class="hltr-red">select加锁</mark>, 都是当前读
- 如果这个update时, 其他事务未commit, 会阻塞等待其他事务释放锁
- <mark class="hltr-green">当前读就是加锁和写入时读取最新记录</mark>
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
