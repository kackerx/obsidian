# 事务

## 隔离级别

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

1. 脏写: 两个事务同时增加余额, 哪个事务先提交就会被下一个写操作覆盖, 『写操作的冲突』, <mark class="hltr-blue">写操作串行执行</mark>
2. 脏读: 事务a读取了事务b未提交的数据, 『读写操作的冲突』, <mark class="hltr-cyan">写完之后再读</mark>
3. 不可重复读: 事务a读取的数据, 被事务b修改后并提交了, 『读写操作的冲突』, <mark class="hltr-grey">读完后再写</mark>
4. 幻读: 一个事务两次读取的范围不同, 和3不同的是, 幻读的重点在于插入, 可重复读的隔离级别会对数据加锁使其不可修改和删除, 但是没法对新增数据加锁, <mark class="hltr-pink">串行化</mark>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240427164337.png|666]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
## 锁

### 间隙锁 & 临键锁
:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

1. Innodb的行锁是对索引加锁而非记录, 索引失效或非索引字段进行修改, 行锁可能变成表锁, for update是排他锁
2. 如图, 索引id的范围左开右闭分别是, (-无穷, 3], (3, 15], (15, 20], (20, +无穷)
3. `where id > 5 and id < 16`, 占据了以上两个范围, 所以(3, 20]加gap锁
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240427164821.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::