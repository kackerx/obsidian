:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-primary
title: try

- 提交订单状态设置为『待提交』, 调用库存服务『预扣减』库存
- 具体操作是库存表中, 将商品库存数量减去订单传递的数量, 同时在预扣减字段增加该数量

~~~

~~~ad-grey
title: Confirm

- Try成功则执行Confirm, 将订单更新为『已提交』
- 库存服务则将库存表中『预扣减』字段减去传递数量, 实现真正扣减库存
~~~

~~~ad-danger
title: Cancel

- Try失败则执行Cancel, 将订单更新为『已取消』
- 库存服务的『库存』字段增加传递数量, 同时对预扣减字段减去传递数量, 实现回滚
~~~

~~~ad-ex
title: 流程

- Try: 不执行任何业务逻辑, 仅做业务的一致性检查和预留相应资源, 这些资源与其他操作是隔离的
- Confirm: Try所有分支事务执行成功, 通常认为Confirm阶段不会出错和失败(预留资源), 重试机制和人工处理
- Cancel: 回滚事务, 取消操作, 释放Try预留的资源
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240427211245.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## 问题

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=3 largest-column=firs}

~~~ad-tips
title: 空回滚

1. 分支事务服务器异常, 此时分支未执行Try操作, 恢复后TCC执行回滚调用分支事务的Cancel, 取消不了没有执行Try
2. 解决方案: 判断是否执行了Try方法 -> 
	1. 主事务发起时, 生成全局事务记录全局唯一事务ID, 再创建一张分支事务记录表记录分支事务(?是分支事务来建
	2. 执行Try时将全局事务和分支事务ID保存到分支事务表, 执行Cancel回滚时首先读取分支事务表, 看是否存在分支事务ID
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-warn
title: 幂等问题

- 分支事务记录表中增加事务的执行状态, 每次执行分支事务, Confirm, Cancel时依此判断事务幂等性
~~~


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-bug
title: 悬挂问题

- 分支事务的RPC调用超时, TM通知RM回滚, RM回滚完毕后RPC的超时又到达了执行了Try来预留资源, 称之为悬挂
- 思路是如果执行了Confirm或Cancel就不能再执行Try, 方案是执行Try时判断分支记录表是否存在同一全局事务下Confirm或Cancel阶段的事务记录
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
