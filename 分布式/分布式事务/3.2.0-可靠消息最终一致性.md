:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-inf
title: ov

事务发起方执行完本地事务后, 发出一条消息, 事务的参与方一定能收到消息并处理成功, 强调的是只要事务发起方发消息给参与方, 
参与方就一定能执行成功, 最终一致

- 电商支付场景ex: 订单服务发送Rocket, Half消息, 发送后响应Half消息发送成功的状态
- 订单服务执行本地事务, 修改订单状态, 并向RocketMQ发送提交事务或者回滚事务的另一半消息
- 如果是commit消息, MQ向库存服务投递事务消息执行分支事务
- 如果是回滚消息, MQ删除相应的half消息, 不再执行分支事务
- 这是基于MQ事务消息, 也可以根据本地消息表, 
- 需要实现『服务模式』, 可查询操作和幂等操作
~~~

</br>

~~~ad-ex
title: 流程

- 事务发起方将消息发送给可靠消息服务(本地消息表或者消息队列实现)
- 发起方 --> 可靠消息服务 --> 参与方, 三者网络通信可能得一致性问题通过引入<mark class="hltr-pink">消息确认服务</mark>和<mark class="hltr-blue">消息恢复服务</mark>
- 消息确认服务: 定期检测发起方业务的执行状态和消息库消息是否一致, 确保本地事务成功后, 消息一定发送成功
- 消息恢复服务: 定期检测参与方业务的执行状态和消息库消息是否一致, 确保参与方的本地事务失败, 但是消息状态变成已消费
~~~

</br>

~~~ad-danger
title: 服务模式

- 可查询操作
- 幂等操作
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240427214507.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## 问题

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=3 largest-column=firs}

~~~ad-primary
title: 本地事务 & 消息发送的原子性问题

通过『消息确认服务』来解决本地事务和消息发送的原子性问题
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-grey
title: 事务消费方接收消息的可靠性问题

- 网络异常导致消费方不能接收到消息, 或者接收消息处理中异常, 不能处理结果回传消息库, 产生的消息可靠性问题
- 通过『消息恢复服务』保证消费方的可靠性
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-inf
title: 事务消费方接收消息的幂等性问题

- 可靠消息多次发送消息后的重复消费消息幂等性问题
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

