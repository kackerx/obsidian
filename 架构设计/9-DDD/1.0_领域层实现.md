
## 领域层实现 - 

```cardlink
url: https://juejin.cn/post/7146248107654103070#heading-25
title: "DDD在Golang中的落地 - 掘金"
description: "DDD中文又叫领域驱动设计，是我们解决复杂业务问题时非常有效的一个手段，但其本身过于陡峭的学习曲线，也让很多初学者知难而退。 网上虽然充斥着很多关于DDD的学习资料，但大多只是偏向于基本概念的介绍，缺"
host: juejin.cn
favicon: https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/favicon-32x32.png
```

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-danger
title: 值对象 - domain/aggregate/valueobject

- 不变性, 值对象创建后不应该被修改, 否则就换新
- 无身份标识, 只判断字段是否全部相同, 如纸币的价值而不关注纸币编号
~~~

~~~ad-grey
title: vo

- 值对象大驼峰, 全局可见, 不仅领域层可以使用
- 值对象成员小写, 避免包外修改, 必须使用New构造一个对象
- 包外如果需要访问成员, 定义一个方法如此处的Amount()
~~~

~~~ad-note
title: note

- 最好不要持有指针, slice类型, 避免属性被修改
- 当需要修改属性值的时候, 返回一个新对象, 如Add() -> newOB
~~~

~~~ad-bug
title: 枚举

- 枚举可以定义在值对象这里
- 或者原始基础类型, 或者...
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240428145401.png|666]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-success
title: 实体 - domain/aggregate/entity

- 实体和数据对象: 数据对象一般值model内定义的和数据库一致的通过orm的对象实例, 贫血模型
- 实体就是拥有唯一标识, 可变的, 具有领域行为的充血对象

~~~

~~~ad-tips
title: 唯一标识

- 唯一标识不是说就应该是数据库主键id, 可以是订单号
- 甚至可以用一个值对象来当唯一标识, 
~~~

~~~ad-danger
title: 聚合根

- 有时候对于简单点的模型, 比如Order可以直接引用OrderRows, 实体Order就是实体+聚合根的双重身份
- 通常不要在一个聚合根中引用另一个聚合根, 正确做法是一个聚合根引用另一个聚合根的全局唯一标识, 如订单聚合根内包含验收单的code, 而不是验收聚合根
- 原因在于一个事务原则上只能修改一个聚合, 不持有引用就避免修改其他聚合根
- 一个事务如果必须修改多个聚合可能意味着聚合的一致性边界是错误的

</br>

- 构建聚合根: 通常是是在app层的command.handle方法中构建
- 1: 直接调用domain/agg/xx_agg.go中的NewEntity方法
- 2: 调用domain/factory/xx_factory.go中的工厂方法/建造者方法
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240428151148.png|555]]
值对象作为唯一标识

![[Pasted image 20240428151653.png|555]]
聚合根


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-tips
title: 领域服务

- 多个领域对象的逻辑封装, 如评论功能, 需要判断文章是否开启评论, 用户是否被禁言, 评论的内容是否合法, 此时要在实体, 值对象的基础上引入领域服务
- 如非必要, 可以不使用领域服务
~~~

~~~ad-danger
title: 何时需要

- 如非必要不要, 因为创建领域服务成本低, 很容易不管什么业务逻辑都丢进去, 造成实体, 值对象的贫血
- 判断要不要其实就是确定某个逻辑不适合放到实体和值对象中

1. ex: 比如说文章实体获取全部有效评论, 需要看评论的db, 但我们的实体对象不可能有commentRepo这个属性, 函数的参数也不可能传递Repo
2. 此时, 用到领域服务来, 其实就是当需要与外部资源进行交互时, 如依赖某个数据资源, 比如某个逻辑需要调用RPC
3. 多个实体有交互: 如发表评论功能, 文章是否开启评论, 评论用户权限, 评论内容合法不是某个单独实体的职责
4. 无法放到某个实体, 如登录, 功能定义到User实体的话, User未登录获取不到User对象, 把逻辑提升到领域服务中
5. 执行一个显著的业务操作
6. 对领域对象进行转换
7. 以多个领域对象对输入, 输出一个值对象
~~~

~~~ad-inf
title: 实现领域服务

- 属性要定义在领域层, 核心层不能引用其他层
- 构造参数是接口, 多态, 方便测试, 通过依赖反转注入
- 全局唯一实例, 启动时new一个注入
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240428153212.png|666]]
文章实体有效评论

![[Pasted image 20240428153633.png|666]]
何时

![[Pasted image 20240428155159.png|666]]
实现领域服务

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-primary
title: 工厂

- 用来创建一个聚合根, 有的聚合根较为复杂, 隐藏创建的细节, 如调用服务获取一些数据, 根据编号生成一些数据, 校验属性
- 1: 可以是一个简单的new方法, 2: 如果依赖外部服务, 需要一个builder对象
~~~

~~~ad-danger
title: 校验

- 单个属性校验, 简单的单个属性校验, 也可以用函数如`if err := setAmount(amount)`
- 对象整体的校验, 可以定义一个校验器抽离校验逻辑, 或者直接是个方法validatePost(\*Post)
- 对于多个对象组合的这种校验, 在领域服务中进行
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240428163454.png|666]]
定义校验器

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---
:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-warn
title: 领域事件

- 通用的领域事件, 有Id, 事件发生时间
- 聚合根的事件, 拥有聚合根唯一标识
~~~

~~~ad-success
title: 事件发布

- publisher通过函数参数传递 - 污染函数
- 全局变量(静态方法)直接发布 - 难以测试
- 事件表, 异步定时
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240428164717.png|666]]

![[Pasted image 20240428164734.png|666]]

![[Pasted image 20240428165533.png]]
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
