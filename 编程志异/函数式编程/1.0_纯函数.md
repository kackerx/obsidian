# 函数式编程

> 面向对象是对现实世界的实体进行抽象, 函数式编程(FP)是对实体间的关系抽象(运算过程)

```go
add := func(a, b int) int { return a + b } // 这就是一层抽象
```
## 纯函数的优点
- 没有副作用, 透明可替换
- 结果可缓存
```go
func add(x, y int) int {  
    cache := map[string]int{}  
    key := fmt.Sprintf(`%d_%d`, x, y)  
    if val, ok := cache[key]; ok {  
       return val  
    }  
  
    res := x + y  
    cache[key] = res  
    return res  
}
```
- 方便测试, 始终存在输入输出
- 方便并行, 纯函数不需要访问共享的全局内存数据, 不依赖函数外部的状态

## 如何不纯 --> 纯

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

- 不可变性, 不修改结构体的值(不传指针, 克隆且返回新对象), map会被修改和传引用一样, slice不会, 通常append会触发扩容新对象且切片的len和cap是不会变的变化的是底层引用的数组, 但是传递&slice就不一样了(len, cap)
- 一个函数只做一件事, 拆分函数
- 如果是单例对象(或全局变量), 使用指针而不是副本也能够避免单例的多个不同复制结果

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



