:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

1. TLS(Transport Layer Security)和SSL(Secure Sockets Layer), TLS是SSL的升级版, 目前是TLS v1.2
2. OpenSSL: 底层密码库, 封装了所有的密码学算法, 证书管理, TLS/SSL协议的实现
3. HTTPS: HTTPS = HTTP + TLS/SSL

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240305145554.png|333]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## 密钥协商算法 [[3_非对称加密算法#^e4e34a]]

## 关于中间人攻击

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-primary
title:  

1. 非对称加密RSA其实也避免不了中间人攻击
2. 服务器给客户端的公钥可能被中间人替换
3. 中间人生成密钥对, 公钥给客户端, 客户端公钥加密key发给服务端结果发给中间人, 中间人私钥解密后获取和客户端数据
4. 中间人自己生成key发给服务器, 获取和服务器的数据
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240305175222.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## PKI - 信任的证书

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

1. 国家发身份证(证书) --> 公民(服务器) --> 银行(客户端浏览器)
2. 证书包含了服务器的主机, 公钥
3. 非对称加密RSA的数字签名技术(私钥加密公钥解密, 认证消息来源者的身份)来认证身份: CA机自己的RSA密钥对(和服务器的RSA密钥对毫无关系),  私钥对证书签名, 签名证书发给服务器
4. 浏览器访问服务器时, 服务器发送证书给浏览器, 浏览器内嵌CA机构的公钥来解密证书, 校验成功确认证书确实是CA颁发且用户访问的网址=证书包含的域名, 从证书中获取服务器的公钥来进行密钥协商

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20221110172436.png|777]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
## 证书流程

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-danger
title: 申请流程

- 服务器生成RSA密钥对
- 服务器生成一个CSR(Ceriticate Signing Request)文件, 其中包含网站域名, RSA公钥, 营业执照等, 发送给CA机构申请证书
- CA收到CSR后核实申请者身份, 校验域名的拥有者是不是证书的申请者
- CA机构用自己的密钥对(如ECDSA密钥对)的私钥签名证书文件, 证书包含域名, 服务器公钥, CA名称等
- CA机构下发证书给服务器
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

~~~ad-note
title: 客户端校验流程

- 浏览器第一次请求服务器, 服务器将证书和RSA公钥返回给浏览器
- 浏览器内置CA根证书, 证书包含CA机构的公钥用于验证签名
- 验签成功说明服务器证书是合法CA颁发
- 从合法证书中取得RSA公钥和主机名等同于浏览器自身访问的主机和第一步服务器返回的公钥则成功校验了服务器的身份
- 密钥协商出会话密钥key
- 客户端公钥加密key给服务器, 中间人无私钥无法解密key, 服务器私钥解密key, key只有客户端和服务器知道, 双方通过这个key进行对称加密通信

~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
## 完整流程总结

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-primary
title: 握手层
1. TLS协议分成握手层 + 加密层
2. 双方交换一些信息, 如协议版本号, 随机数, 密码套件(suit, 密码学算法组合)等
3. 客户端通过服务器返回的证书确认服务器身份后, 协商出预备主秘钥, 主密钥, 密钥块
4. 后续应用层数据可以通过加密层进行机密性和完整性保证

~~~

~~~ad-grey
title: 加密层

1. 如右图下的加解密数据
~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240306101038.png|555]]

![[Pasted image 20240306101055.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
