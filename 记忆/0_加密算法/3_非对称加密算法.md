# 非对称加密算法 (公开密钥算法)

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

1. 密钥对, 公开的公钥加密, 私钥服务端保存用来解密
2. RSA算法中, 公钥和私钥不只是一串字符, 由很多参数组成, 一般以文件形式, 秘钥文件的内部结构如图
3. 密钥文件生成过程
	1. 选取两个很大的质数p和q
	2. n = p x q
	3. 取公开指数e, e < (p-1)(q-1), e和(p-1)(q-1)互为质数
	4. (e, n) --> 公钥, n的长度就相当于密钥对的长度
	5. (e, p, q) --> (d, n) --> 私钥 
4. 加密过程
	1. C = M^e (mod n)
	2. M = C^d (mod n)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240305155952.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
## RSA用于密钥协商算法

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-ex
title: 密钥协商算法

1. 客户端初始连接服务端, 服务端发送RSA公钥给客户端
2. 客户端生成随机值key(会话密钥)
3. 客户端公钥加密key, 中间人没私钥无法拦截, 服务端使用私钥解密得到key
4. 客户端和服务端使用对称加密算法 + key来进行通信

~~~

^e4e34a

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## 数字签名

:::::::::::::::::::::::::::::::::::::::: {.columns shadow=off border=off col-count=2 largest-column=firs}

~~~ad-danger
title: 签名

1. 加密算法不能『防抵赖』, ABC共享对称加密密钥, A给B发消息, B无法证明是A还是C发的
2. RSA中, 私钥拥有者使用秘钥签署一条消息, 接收方公钥解密消息, 只有私钥持有者才能『签署』消息所以不能抵赖
3. MAC能保证传递的消息是经过验证的但是不能对发送者身份进行验证, 因为双方密钥相同, 可能有第三方也持有, 可以抵赖
4. 所以MAC是消息验证, 签名是身份验证
~~~

~~~ad-note
title: 流程

1. 消息摘要后, 发送者用私钥进行签名, 原消息 + 签名值 --> 接收者
2. 接收者使用公钥对签名值得到消息摘要, 然后比较消息摘要
3. RSA加密是公钥加密, 私钥解密, 签名则是私钥签名, 公钥验证签名

~~~

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::columnbreak
:::

![[Pasted image 20240305164727.png|555]]

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
